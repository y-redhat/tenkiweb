<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¹³å®‰æ™‚ä»£æ°—è±¡å†ç¾ã‚·ã‚¹ãƒ†ãƒ  - å®Œå…¨ç‰©ç†ãƒ¢ãƒ‡ãƒ«</title>
    <style>
        :root {
            --primary-color: #1a237e;
            --secondary-color: #283593;
            --accent-color: #536dfe;
            --warning-color: #ff6b6b;
            --success-color: #4caf50;
            --text-primary: #333;
            --text-secondary: #666;
            --bg-primary: #f5f7ff;
            --bg-secondary: #e8eaf6;
            --bg-card: #ffffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans JP', 'Hiragino Kaku Gothic Pro', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem;
            border-radius: 15px;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(26, 35, 126, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }
        
        .header .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        /* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
        .main-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« */
        .control-panel {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            height: fit-content;
        }
        
        .section-title {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin: 25px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--bg-secondary);
            font-weight: 600;
        }
        
        .section-title:first-child {
            margin-top: 0;
        }
        
        /* å…¥åŠ›è¦ç´  */
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        select, input[type="range"], input[type="number"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            background: white;
            transition: all 0.3s;
            font-family: inherit;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(83, 109, 254, 0.1);
        }
        
        .slider-value {
            text-align: center;
            margin-top: 5px;
            color: var(--accent-color);
            font-weight: bold;
        }
        
        /* å ´æ‰€é¸æŠ */
        .location-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .location-btn {
            padding: 12px;
            border: 2px solid var(--bg-secondary);
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            text-align: center;
        }
        
        .location-btn:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
        }
        
        .location-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        /* æ°—è±¡æ¡ä»¶é¸æŠ */
        .weather-condition {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .condition-btn {
            padding: 15px;
            border: 2px solid var(--bg-secondary);
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .condition-btn:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
        }
        
        .condition-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        .condition-icon {
            font-size: 2rem;
            margin-bottom: 5px;
        }
        
        /* ãƒœã‚¿ãƒ³ */
        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 25px;
        }
        
        .btn {
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-color), #3d5afe);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(83, 109, 254, 0.3);
        }
        
        /* ãƒãƒƒãƒ—ã‚³ãƒ³ãƒ†ãƒŠ */
        .map-container {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            position: relative;
            min-height: 800px;
        }
        
        .map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--bg-secondary);
        }
        
        .era-display {
            font-size: 1.8rem;
            color: var(--primary-color);
            font-weight: 700;
        }
        
        #weatherCanvas {
            width: 100%;
            height: 700px;
            border-radius: 10px;
            border: 2px solid var(--bg-secondary);
            background: #e8f4f8;
        }
        
        /* å…¬å¼ãƒ‘ãƒãƒ« */
        .formula-panel {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 25px;
            margin-top: 25px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
        }
        
        .formula-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .formula-card {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid var(--accent-color);
        }
        
        .formula-name {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .formula-equation {
            font-family: 'Courier New', monospace;
            background: var(--primary-color);
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 1rem;
            overflow-x: auto;
        }
        
        .formula-value {
            color: var(--warning-color);
            font-weight: bold;
        }
        
        .formula-details {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        /* å‡¡ä¾‹ */
        .legend {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .main-grid {
                gap: 15px;
            }
            
            .weather-condition {
                grid-template-columns: 1fr;
            }
            
            .formula-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <header class="header">
            <h1>å¹³å®‰æ™‚ä»£æ°—è±¡å†ç¾ã‚·ã‚¹ãƒ†ãƒ </h1>
            <p class="subtitle">å®Œå…¨ç‰©ç†ãƒ¢ãƒ‡ãƒ« Ã— å‹•çš„æ°—åœ§å ´ Ã— æ­´å²çš„æ–‡çŒ®çµ±åˆ</p>
        </header>
        
        <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
        <div class="main-grid">
            <!-- å·¦å´: ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
            <div class="control-panel">
                <!-- æ™‚ä»£é¸æŠ -->
                <div class="section-title">
                    <i class="fas fa-history"></i>
                    æ™‚ä»£é¸æŠ
                </div>
                
                <div class="input-group">
                    <label for="yearSelect">è¥¿æš¦æŒ‡å®š (794-1185)</label>
                    <input type="range" id="yearSelect" min="794" max="1185" value="1000" step="1">
                    <div class="slider-value" id="yearValue">å¹³å®‰ä¸­æœŸ (1000å¹´)</div>
                </div>
                
                <!-- å ´æ‰€é¸æŠ -->
                <div class="section-title">
                    <i class="fas fa-map-marker-alt"></i>
                    å ´æ‰€é¸æŠ
                </div>
                
                <div class="location-buttons">
                    <button class="location-btn active" data-location="kyoto">äº¬éƒ½</button>
                    <button class="location-btn" data-location="nara">å¥ˆè‰¯</button>
                    <button class="location-btn" data-location="kamakura">éŒå€‰</button>
                    <button class="location-btn" data-location="hakata">åšå¤š</button>
                    <button class="location-btn" data-location="osaka">å¤§å‚</button>
                    <button class="location-btn" data-location="sendai">ä»™å°</button>
                </div>
                
                <!-- æ°—è±¡æ¡ä»¶ -->
                <div class="section-title">
                    <i class="fas fa-cloud"></i>
                    æ°—è±¡æ¡ä»¶
                </div>
                
                <div class="weather-condition">
                    <button class="condition-btn" data-weather="sunny">
                        <div class="condition-icon">â˜€ï¸</div>
                        <div>æ™´ã‚Œ</div>
                    </button>
                    <button class="condition-btn" data-weather="cloudy">
                        <div class="condition-icon">â˜ï¸</div>
                        <div>æ›‡ã‚Š</div>
                    </button>
                    <button class="condition-btn" data-weather="rainy">
                        <div class="condition-icon">ğŸŒ§ï¸</div>
                        <div>é›¨</div>
                    </button>
                    <button class="condition-btn" data-weather="snowy">
                        <div class="condition-icon">â„ï¸</div>
                        <div>é›ª</div>
                    </button>
                    <button class="condition-btn" data-weather="stormy">
                        <div class="condition-icon">â›ˆï¸</div>
                        <div>åµ</div>
                    </button>
                    <button class="condition-btn" data-weather="foggy">
                        <div class="condition-icon">ğŸŒ«ï¸</div>
                        <div>éœ§</div>
                    </button>
                </div>
                
                <!-- ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ -->
                <div class="section-title">
                    <i class="fas fa-sliders-h"></i>
                    ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                </div>
                
                <div class="input-group">
                    <label for="temperature">å¹³å‡æ°—æ¸©: <span id="tempValue">24.5</span>Â°C</label>
                    <input type="range" id="temperature" min="20" max="30" value="24.5" step="0.1">
                </div>
                
                <div class="input-group">
                    <label for="humidity">æ¹¿åº¦: <span id="humidityValue">60</span>%</label>
                    <input type="range" id="humidity" min="30" max="100" value="60" step="1">
                </div>
                
                <div class="input-group">
                    <label for="pressure">åŸºæº–æ°—åœ§: <span id="pressureValue">1013</span> hPa</label>
                    <input type="range" id="pressure" min="980" max="1040" value="1013" step="1">
                </div>
                
                <div class="input-group">
                    <label for="enso">ENSOæŒ‡æ•°: <span id="ensoValue">0.0</span></label>
                    <input type="range" id="enso" min="-2" max="2" value="0" step="0.1">
                </div>
                
                <!-- æ“ä½œãƒœã‚¿ãƒ³ -->
                <div class="section-title">
                    <i class="fas fa-cogs"></i>
                    æ“ä½œ
                </div>
                
                <div class="button-group">
                    <button class="btn btn-primary" id="generateBtn">
                        <i class="fas fa-bolt"></i>
                        æ°—è±¡ç”Ÿæˆ
                    </button>
                    <button class="btn btn-primary" id="animateBtn">
                        <i class="fas fa-play"></i>
                        ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                    </button>
                    <button class="btn btn-primary" id="formulaBtn">
                        <i class="fas fa-calculator"></i>
                        å…¬å¼è¡¨ç¤º
                    </button>
                </div>
            </div>
            
            <!-- å³å´: åœ°å›³è¡¨ç¤º -->
            <div class="map-container">
                <div class="map-header">
                    <div class="era-display" id="eraDisplay">å¹³å®‰ä¸­æœŸ (è¥¿æš¦1000å¹´)</div>
                    <div>
                        <div id="weatherDisplay">å¤©æ°—: æ™´ã‚Œ</div>
                        <div id="locationDisplay">å ´æ‰€: äº¬éƒ½</div>
                    </div>
                </div>
                
                <canvas id="weatherCanvas"></canvas>
                
                <!-- å‡¡ä¾‹ -->
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #0066CC;"></div>
                        <span>é«˜æ°—åœ§ä¸­å¿ƒ</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #CC0000;"></div>
                        <span>ä½æ°—åœ§ä¸­å¿ƒ</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #009900;"></div>
                        <span>ç­‰åœ§ç·š (4hPaé–“éš”)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF9900;"></div>
                        <span>æ¸©æš–åŸŸ</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #0000CC;"></div>
                        <span>å¯’å†·åŸŸ</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- å…¬å¼ãƒ‘ãƒãƒ« -->
        <div class="formula-panel" id="formulaPanel">
            <h3 style="color: var(--primary-color); margin-bottom: 20px;">
                <i class="fas fa-square-root-alt"></i>
                ä½¿ç”¨ã—ãŸæ°—è±¡å­¦å…¬å¼
            </h3>
            
            <div class="formula-grid" id="formulasList">
                <!-- å…¬å¼ãŒã“ã“ã«å‹•çš„ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
            </div>
        </div>
    </div>

    <!-- ã‚¹ã‚¯ãƒªãƒ—ãƒˆ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"></script>
    
    <script>
        // ==================== 1. å®Œå…¨ç‰©ç†ãƒ¢ãƒ‡ãƒ«æ°—è±¡ã‚¨ãƒ³ã‚¸ãƒ³ ====================
        class CompleteMeteorologicalEngine {
            constructor() {
                // ç‰©ç†å®šæ•°
                this.constants = {
                    // æ”¾å°„ãƒ»æ¸©åº¦ç³»
                    SOLAR_CONSTANT: 1361,           // å¤ªé™½å®šæ•° (W/mÂ²)
                    STEFAN_BOLTZMANN: 5.67e-8,      // ã‚¹ãƒ†ãƒ•ã‚¡ãƒ³ãƒ»ãƒœãƒ«ãƒ„ãƒãƒ³å®šæ•°
                    ALBEDO_EARTH: 0.3,              // åœ°çƒã‚¢ãƒ«ãƒ™ãƒ‰
                    CLIMATE_SENSITIVITY: 0.8,       // æ°—å€™æ„Ÿåº¦ (K/(W/mÂ²))
                    
                    // æ°—åœ§ãƒ»é«˜åº¦ç³»
                    GRAVITY: 9.80665,               // é‡åŠ›åŠ é€Ÿåº¦ (m/sÂ²)
                    SCALE_HEIGHT: 8400,             // ã‚¹ã‚±ãƒ¼ãƒ«ãƒã‚¤ãƒˆ (m)
                    GAS_CONSTANT_DRY: 287.05,       // ä¹¾ç‡¥ç©ºæ°—ã®æ°—ä½“å®šæ•° (J/(kgÂ·K))
                    
                    // é¢¨ãƒ»å›è»¢ç³»
                    EARTH_OMEGA: 7.2921e-5,         // åœ°çƒè‡ªè»¢è§’é€Ÿåº¦ (rad/s)
                    AIR_DENSITY: 1.225,             // æ¨™æº–ç©ºæ°—å¯†åº¦ (kg/mÂ³)
                    
                    // æ¹¿åº¦ãƒ»ç†±åŠ›å­¦
                    LAPSE_RATE: 6.5,                // æ°—æ¸©æ¸›ç‡ (K/km)
                    DRY_ADIABATIC_LAPSE: 9.8,       // ä¹¾ç‡¥æ–­ç†±æ¸›ç‡ (K/km)
                    CP_AIR: 1005,                   // å®šåœ§æ¯”ç†± (J/(kgÂ·K))
                    
                    // å­£ç¯€ãƒ»å¤©æ–‡
                    OBLIQUITY: 23.44,               // é»„é“å‚¾æ–œè§’ (åº¦)
                    DAYS_PER_YEAR: 365.25
                };
            }
            
            // ğŸŒ 1. æ”¾å°„ãƒ»æ°—æ¸©ç³»
            radiativeEquilibrium(albedo = this.constants.ALBEDO_EARTH) {
                const S = this.constants.SOLAR_CONSTANT;
                const sigma = this.constants.STEFAN_BOLTZMANN;
                const T = Math.pow((1 - albedo) * S / (4 * sigma), 0.25) - 273.15;
                
                return {
                    value: T,
                    formula: "(1-Î±)S/4 = ÏƒTâ´",
                    explanation: "æ”¾å°„å¹³è¡¡æ¸©åº¦ (åœ°çƒå¹³å‡)",
                    details: {
                        albedo: albedo,
                        solarConstant: S,
                        stefanBoltzmann: sigma.toExponential(2)
                    }
                };
            }
            
            radiativeForcing(deltaF, lambda = this.constants.CLIMATE_SENSITIVITY) {
                const deltaT = lambda * deltaF;
                
                return {
                    value: deltaT,
                    formula: "Î”T = Î»Â·Î”F",
                    explanation: "æ”¾å°„å¼·åˆ¶åŠ›ã«ã‚ˆã‚‹æ°—æ¸©å¤‰åŒ–",
                    details: {
                        deltaF: deltaF,
                        lambda: lambda,
                        unit: "K/(W/mÂ²)"
                    }
                };
            }
            
            lapseRateCorrection(temp, height) {
                const correctedTemp = temp - this.constants.LAPSE_RATE * (height / 1000);
                
                return {
                    value: correctedTemp,
                    formula: "T(z) = Tâ‚€ - Î“Â·z",
                    explanation: "æ¨™é«˜è£œæ­£ (æ°—æ¸©æ¸›ç‡)",
                    details: {
                        initialTemp: temp,
                        height: height,
                        lapseRate: this.constants.LAPSE_RATE,
                        unit: "K/km"
                    }
                };
            }
            
            // ğŸ§± 2. æ°—åœ§ãƒ»é«˜åº¦ã®å…¬å¼
            hydrostaticBalance(p0, rho, g = this.constants.GRAVITY) {
                const dpdz = -rho * g;
                
                return {
                    value: dpdz,
                    formula: "dp/dz = -Ïg",
                    explanation: "é™æ°´åœ§å¹³è¡¡",
                    details: {
                        density: rho,
                        gravity: g,
                        unit: "Pa/m"
                    }
                };
            }
            
            pressureAtHeight(P0, z, H = this.constants.SCALE_HEIGHT) {
                const P = P0 * Math.exp(-z / H);
                
                return {
                    value: P,
                    formula: "P(z) = Pâ‚€Â·exp(-z/H)",
                    explanation: "æ°—åœ§é«˜åº¦å¼",
                    details: {
                        P0: P0,
                        height: z,
                        scaleHeight: H
                    }
                };
            }
            
            idealGasLaw(P, T) {
                const rho = P / (this.constants.GAS_CONSTANT_DRY * (T + 273.15));
                
                return {
                    value: rho,
                    formula: "P = ÏRT",
                    explanation: "çŠ¶æ…‹æ–¹ç¨‹å¼ (ä¹¾ç‡¥ç©ºæ°—)",
                    details: {
                        pressure: P,
                        temperature: T,
                        gasConstant: this.constants.GAS_CONSTANT_DRY
                    }
                };
            }
            
            // ğŸŒ¬ï¸ 3. é¢¨ã®å…¬å¼
            coriolisParameter(latitude) {
                const f = 2 * this.constants.EARTH_OMEGA * Math.sin(latitude * Math.PI / 180);
                
                return {
                    value: f,
                    formula: "f = 2Î©sinÏ†",
                    explanation: "ã‚³ãƒªã‚ªãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿",
                    details: {
                        latitude: latitude,
                        omega: this.constants.EARTH_OMEGA.toExponential(3),
                        unit: "sâ»Â¹"
                    }
                };
            }
            
            geostrophicWind(pressureGradient, latitude) {
                const f = this.coriolisParameter(latitude).value;
                const rho = this.constants.AIR_DENSITY;
                
                const Vg = (1 / (rho * f)) * pressureGradient;
                
                return {
                    speed: Math.abs(Vg),
                    direction: pressureGradient > 0 ? 90 : 270,
                    formula: "fv = (1/Ï)Â·âˆ‚p/âˆ‚x",
                    explanation: "åœ°è¡¡é¢¨ (åŒ—åŠçƒ)",
                    details: {
                        pressureGradient: pressureGradient,
                        coriolis: f.toExponential(3),
                        density: rho,
                        unit: "m/s"
                    }
                };
            }
            
            windSpeed(u, v) {
                const speed = Math.sqrt(u * u + v * v);
                
                return {
                    value: speed,
                    formula: "|v| = âˆš(uÂ² + vÂ²)",
                    explanation: "é¢¨é€Ÿã®å¤§ãã•",
                    details: {
                        uComponent: u,
                        vComponent: v
                    }
                };
            }
            
            // ğŸ’§ 4. æ¹¿åº¦ãƒ»æ°´è’¸æ°—
            saturationVaporPressure(T) {
                const es = 6.11 * Math.exp(17.27 * T / (T + 237.3));
                
                return {
                    value: es,
                    formula: "eâ‚› = 6.11Â·exp(17.27T/(T+237.3))",
                    explanation: "é£½å’Œæ°´è’¸æ°—åœ§ (ãƒã‚°ãƒŒã‚¹å¼)",
                    details: {
                        temperature: T,
                        unit: "hPa"
                    }
                };
            }
            
            relativeHumidity(e, es) {
                const RH = (e / es) * 100;
                
                return {
                    value: RH,
                    formula: "RH = (e/eâ‚›)Ã—100",
                    explanation: "ç›¸å¯¾æ¹¿åº¦",
                    details: {
                        vaporPressure: e,
                        saturationPressure: es,
                        unit: "%"
                    }
                };
            }
            
            specificHumidity(e, P) {
                const q = 0.622 * e / (P - 0.378 * e);
                
                return {
                    value: q,
                    formula: "q = 0.622e/(P-0.378e)",
                    explanation: "æ¯”æ¹¿",
                    details: {
                        vaporPressure: e,
                        pressure: P,
                        unit: "kg/kg"
                    }
                };
            }
            
            // ğŸŒ§ï¸ 5. é™æ°´ãƒ»é›²
            upwardMotionCondition(divergence) {
                const upward = divergence < 0;
                
                return {
                    value: upward,
                    formula: "âˆ‡Â·v < 0 â†’ ä¸Šæ˜‡æµ",
                    explanation: "ä¸Šæ˜‡æµåˆ¤å®š",
                    details: {
                        divergence: divergence,
                        condition: upward ? "ä¸Šæ˜‡" : "ä¸‹é™"
                    }
                };
            }
            
            rainfallEstimate(RH, w, a = 0.01) {
                const rain = a * RH * w;
                
                return {
                    value: rain,
                    formula: "Rain â‰ˆ aÂ·RHÂ·w",
                    explanation: "é™æ°´é‡ãƒ¢ãƒ‡ãƒ« (çµŒé¨“å¼)",
                    details: {
                        humidity: RH,
                        updraft: w,
                        coefficient: a,
                        unit: "mm/h"
                    }
                };
            }
            
            cloudCoverEstimate(RH) {
                const cloud = RH * RH / 10000; // RHÂ² ã®ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
                
                return {
                    value: cloud,
                    formula: "Cloud â‰ˆ RHÂ²",
                    explanation: "é›²é‡æ¨å®š",
                    details: {
                        relativeHumidity: RH,
                        unit: "å‰²åˆ (0-1)"
                    }
                };
            }
            
            // ğŸ”º 6. å‰ç·šãƒ»æ°—å›£
            frontIntensity(temperatureGradient) {
                const intensity = Math.abs(temperatureGradient);
                
                return {
                    value: intensity,
                    formula: "F = |âˆ‡T|",
                    explanation: "å‰ç·šå¼·åº¦ (æ¸©åº¦å‹¾é…)",
                    details: {
                        gradient: temperatureGradient,
                        unit: "K/km"
                    }
                };
            }
            
            temperatureAdvection(vx, vy, dTdx, dTdy) {
                const advection = -(vx * dTdx + vy * dTdy);
                
                return {
                    value: advection,
                    formula: "âˆ‚T/âˆ‚t = -vÂ·âˆ‡T",
                    explanation: "æ¸©åº¦ç§»æµ",
                    details: {
                        windX: vx,
                        windY: vy,
                        gradX: dTdx,
                        gradY: dTdy,
                        unit: "K/s"
                    }
                };
            }
            
            // ğŸ§  7. å¤§æ°—å®‰å®šåº¦
            dryAdiabaticLapseRate() {
                const gamma_d = this.constants.GRAVITY / this.constants.CP_AIR;
                
                return {
                    value: gamma_d * 1000, // K/km
                    formula: "Î“â‚” = g/câ‚š",
                    explanation: "ä¹¾ç‡¥æ–­ç†±æ¸›ç‡",
                    details: {
                        gravity: this.constants.GRAVITY,
                        specificHeat: this.constants.CP_AIR,
                        unit: "K/km"
                    }
                };
            }
            
            stabilityCondition(environmentLapse, dryAdiabaticLapse) {
                const stable = environmentLapse < dryAdiabaticLapse;
                
                return {
                    value: stable,
                    formula: "Î“â‚‘â‚™áµ¥ < Î“â‚” â†’ å®‰å®š",
                    explanation: "å¤§æ°—å®‰å®šåº¦åˆ¤å®š",
                    details: {
                        envLapse: environmentLapse,
                        dryLapse: dryAdiabaticLapse,
                        condition: stable ? "å®‰å®š" : "ä¸å®‰å®š"
                    }
                };
            }
            
            // ğŸŒ 8. å¤§å¾ªç’°ãƒ»å­£ç¯€
            solarAltitudeAngle(latitude, declination, hourAngle) {
                const phi = latitude * Math.PI / 180;
                const delta = declination * Math.PI / 180;
                const H = hourAngle * Math.PI / 12;
                
                const sinh = Math.sin(phi) * Math.sin(delta) + 
                           Math.cos(phi) * Math.cos(delta) * Math.cos(H);
                
                return {
                    value: Math.asin(Math.max(-1, Math.min(1, sinh))) * 180 / Math.PI,
                    formula: "sinh = sinÏ† sinÎ´ + cosÏ† cosÎ´ cosH",
                    explanation: "å¤ªé™½é«˜åº¦è§’",
                    details: {
                        latitude: latitude,
                        declination: declination,
                        hourAngle: hourAngle,
                        unit: "åº¦"
                    }
                };
            }
            
            monsoonIndex(landTemp, seaTemp) {
                const index = landTemp - seaTemp;
                
                return {
                    value: index,
                    formula: "Monsoon âˆ Î”T(land-sea)",
                    explanation: "ãƒ¢ãƒ³ã‚¹ãƒ¼ãƒ³æŒ‡æ¨™",
                    details: {
                        landTemperature: landTemp,
                        seaTemperature: seaTemp
                    }
                };
            }
            
            // ğŸ§ª 9. èª¤å·®ãƒ»è£œæ­£
            movingAverage(data, window) {
                const result = data.map((_, i) => {
                    const start = Math.max(0, i - window);
                    const end = i + 1;
                    const subset = data.slice(start, end);
                    return subset.reduce((a, b) => a + b, 0) / subset.length;
                });
                
                return {
                    value: result,
                    formula: "MA(t) = Î£x(t-i)/n",
                    explanation: "ç§»å‹•å¹³å‡ (å¹³æ»‘åŒ–)",
                    details: {
                        windowSize: window,
                        dataLength: data.length
                    }
                };
            }
            
            biasCorrection(rawTemp, rawMean, obsMean) {
                const corrected = rawTemp - rawMean + obsMean;
                
                return {
                    value: corrected,
                    formula: "T_adj = T_raw - mean_raw + mean_obs",
                    explanation: "ãƒã‚¤ã‚¢ã‚¹è£œæ­£",
                    details: {
                        rawTemperature: rawTemp,
                        rawMean: rawMean,
                        observedMean: obsMean
                    }
                };
            }
            
            uncertaintyPropagation(sigma1, sigma2) {
                const combined = Math.sqrt(sigma1 * sigma1 + sigma2 * sigma2);
                
                return {
                    value: combined,
                    formula: "ÏƒÂ² = Ïƒâ‚Â² + Ïƒâ‚‚Â²",
                    explanation: "ä¸ç¢ºå®Ÿæ€§ä¼æ’­",
                    details: {
                        sigma1: sigma1,
                        sigma2: sigma2
                    }
                };
            }
        }
        
        // ==================== 2. å‹•çš„æ°—åœ§å ´ç”Ÿæˆã‚¯ãƒ©ã‚¹ ====================
        class DynamicPressureField {
            constructor() {
                this.engine = new CompleteMeteorologicalEngine();
                this.lowPressureCenters = [];
                this.highPressureCenters = [];
                this.isobars = [];
                this.windField = [];
                this.timeStep = 0;
            }
            
            generatePressureField(location, weather, temperature, humidity, basePressure, ensoIndex) {
                // å ´æ‰€ã«åŸºã¥ãåŸºæº–åº§æ¨™
                const locations = {
                    kyoto: { lat: 35.0116, lon: 135.7681, elevation: 50 },
                    nara: { lat: 34.6851, lon: 135.8048, elevation: 75 },
                    kamakura: { lat: 35.3192, lon: 139.5500, elevation: 15 },
                    hakata: { lat: 33.5902, lon: 130.4017, elevation: 10 },
                    osaka: { lat: 34.6937, lon: 135.5023, elevation: 20 },
                    sendai: { lat: 38.2682, lon: 140.8694, elevation: 45 }
                };
                
                const loc = locations[location] || locations.kyoto;
                
                // å¤©æ°—æ¡ä»¶ã«åŸºã¥ãæ°—åœ§é…ç½®
                const weatherPatterns = {
                    sunny: { 
                        pattern: "high_dominant",
                        pressureOffset: 15,
                        lowCount: 1,
                        highCount: 2
                    },
                    cloudy: { 
                        pattern: "balanced",
                        pressureOffset: 5,
                        lowCount: 2,
                        highCount: 2
                    },
                    rainy: { 
                        pattern: "low_dominant",
                        pressureOffset: -10,
                        lowCount: 3,
                        highCount: 1
                    },
                    snowy: { 
                        pattern: "cold_low",
                        pressureOffset: -5,
                        lowCount: 2,
                        highCount: 1
                    },
                    stormy: { 
                        pattern: "deep_low",
                        pressureOffset: -20,
                        lowCount: 4,
                        highCount: 0
                    },
                    foggy: { 
                        pattern: "weak_gradient",
                        pressureOffset: 0,
                        lowCount: 1,
                        highCount: 1
                    }
                };
                
                const pattern = weatherPatterns[weather] || weatherPatterns.sunny;
                
                // ä½æ°—åœ§ä¸­å¿ƒã®ç”Ÿæˆï¼ˆé›¨ã®å ´åˆã¯å‘¨å›²ã«ã°ã‚‰ã¾ãï¼‰
                this.lowPressureCenters = [];
                for (let i = 0; i < pattern.lowCount; i++) {
                    let lat, lon;
                    
                    if (weather === 'rainy' && i > 0) {
                        // é›¨ã®å ´åˆã¯ä¸­å¿ƒã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
                        const angle = (i * 72) * Math.PI / 180; // 72åº¦é–“éš”
                        const distance = 1.5 + Math.random() * 1.0; // 1.5-2.5åº¦
                        lat = loc.lat + distance * Math.sin(angle);
                        lon = loc.lon + distance * Math.cos(angle);
                    } else {
                        // ä¸»è¦ãªä½æ°—åœ§
                        lat = loc.lat + (Math.random() - 0.5) * 2;
                        lon = loc.lon + (Math.random() - 0.5) * 2;
                    }
                    
                    const pressure = basePressure + pattern.pressureOffset + 
                                   (Math.random() - 0.5) * 10 - i * 3;
                    
                    this.lowPressureCenters.push({
                        id: `low_${i}`,
                        lat: lat,
                        lon: lon,
                        pressure: pressure,
                        radius: 200 + Math.random() * 200, // km
                        intensity: 1.0 + Math.random() * 0.5,
                        movement: this.calculateMovement(lat, lon, 'low', weather)
                    });
                }
                
                // é«˜æ°—åœ§ä¸­å¿ƒã®ç”Ÿæˆ
                this.highPressureCenters = [];
                for (let i = 0; i < pattern.highCount; i++) {
                    // ä½æ°—åœ§ã‹ã‚‰é›¢ã‚ŒãŸä½ç½®ã«é…ç½®
                    const angle = (i * 120) * Math.PI / 180;
                    const distance = 3 + Math.random() * 2;
                    
                    this.highPressureCenters.push({
                        id: `high_${i}`,
                        lat: loc.lat + distance * Math.sin(angle),
                        lon: loc.lon + distance * Math.cos(angle),
                        pressure: basePressure + 20 + (Math.random() - 0.5) * 8,
                        radius: 300 + Math.random() * 200,
                        intensity: 0.8 + Math.random() * 0.4,
                        movement: this.calculateMovement(lat, lon, 'high', weather)
                    });
                }
                
                // ç­‰åœ§ç·šã®ç”Ÿæˆ
                this.generateIsobars();
                
                // é¢¨å ´ã®è¨ˆç®—
                this.calculateWindField();
                
                return {
                    lows: this.lowPressureCenters,
                    highs: this.highPressureCenters,
                    isobars: this.isobars,
                    winds: this.windField,
                    location: loc,
                    weather: weather,
                    timestamp: new Date().toISOString()
                };
            }
            
            calculateMovement(lat, lon, type, weather) {
                // åŸºæœ¬çš„ãªç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå­£ç¯€ã¨å¤©å€™ã«ã‚ˆã‚‹ï¼‰
                let speed, direction;
                
                if (type === 'low') {
                    speed = 25 + (weather === 'stormy' ? 15 : 0);
                    direction = 60 + (Math.random() - 0.5) * 30; // æ±åŒ—æ±å¯„ã‚Š
                } else {
                    speed = 10 + (Math.random() - 0.5) * 5;
                    direction = 240 + (Math.random() - 0.5) * 60; // è¥¿å—è¥¿å¯„ã‚Š
                }
                
                // ENSOã®å½±éŸ¿
                const enso = parseFloat(document.getElementById('enso').value);
                speed *= (1 + Math.abs(enso) * 0.1);
                
                return {
                    speed: speed,
                    direction: direction,
                    dx: speed * Math.cos(direction * Math.PI / 180) / 111.32,
                    dy: speed * Math.sin(direction * Math.PI / 180) / 111.32
                };
            }
            
            generateIsobars() {
                this.isobars = [];
                const interval = 4; // 4hPaé–“éš”
                
                // ä½æ°—åœ§ä¸­å¿ƒã‹ã‚‰ã®ç­‰åœ§ç·š
                this.lowPressureCenters.forEach(low => {
                    for (let p = Math.floor(low.pressure); p <= Math.floor(low.pressure) + 20; p += interval) {
                        if (p % interval === 0) {
                            this.isobars.push({
                                pressure: p,
                                center: { lat: low.lat, lon: low.lon },
                                radius: this.pressureToRadius(low.pressure, p, low.radius),
                                type: 'low'
                            });
                        }
                    }
                });
                
                // é«˜æ°—åœ§ä¸­å¿ƒã‹ã‚‰ã®ç­‰åœ§ç·š
                this.highPressureCenters.forEach(high => {
                    for (let p = Math.floor(high.pressure); p >= Math.floor(high.pressure) - 20; p -= interval) {
                        if (p % interval === 0) {
                            this.isobars.push({
                                pressure: p,
                                center: { lat: high.lat, lon: high.lon },
                                radius: this.pressureToRadius(high.pressure, p, high.radius),
                                type: 'high'
                            });
                        }
                    }
                });
            }
            
            pressureToRadius(centerPressure, isobarPressure, baseRadius) {
                const pressureDiff = Math.abs(centerPressure - isobarPressure);
                return baseRadius * (1 + pressureDiff / 5); // æ°—åœ§å·®ã«æ¯”ä¾‹ã—ã¦æ‹¡å¤§
            }
            
            calculateWindField() {
                this.windField = [];
                
                // ã‚°ãƒªãƒƒãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ã®é¢¨ã‚’è¨ˆç®—
                for (let lat = 30; lat <= 45; lat += 1) {
                    for (let lon = 125; lon <= 145; lon += 1.5) {
                        // æ°—åœ§å‹¾é…ã®è¨ˆç®—
                        let pressureGradientX = 0;
                        let pressureGradientY = 0;
                        
                        // ä½æ°—åœ§ã‹ã‚‰ã®å¯„ä¸
                        this.lowPressureCenters.forEach(low => {
                            const dx = (lon - low.lon) * 111.32 * Math.cos(lat * Math.PI / 180);
                            const dy = (lat - low.lat) * 111.32;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < low.radius) {
                                const influence = (low.radius - distance) / low.radius;
                                pressureGradientX += influence * (lon - low.lon) / distance * low.intensity;
                                pressureGradientY += influence * (lat - low.lat) / distance * low.intensity;
                            }
                        });
                        
                        // é«˜æ°—åœ§ã‹ã‚‰ã®å¯„ä¸ï¼ˆç¬¦å·åè»¢ï¼‰
                        this.highPressureCenters.forEach(high => {
                            const dx = (lon - high.lon) * 111.32 * Math.cos(lat * Math.PI / 180);
                            const dy = (lat - high.lat) * 111.32;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < high.radius) {
                                const influence = (high.radius - distance) / high.radius;
                                pressureGradientX -= influence * (lon - high.lon) / distance * high.intensity;
                                pressureGradientY -= influence * (lat - high.lat) / distance * high.intensity;
                            }
                        });
                        
                        // åœ°è¡¡é¢¨ã®è¨ˆç®—
                        if (Math.abs(pressureGradientX) > 0.001 || Math.abs(pressureGradientY) > 0.001) {
                            const gradient = Math.sqrt(pressureGradientX * pressureGradientX + pressureGradientY * pressureGradientY);
                            const wind = this.engine.geostrophicWind(gradient, lat);
                            
                            // é¢¨å‘ã®è¨ˆç®—ï¼ˆæ°—åœ§å‚¾åº¦åŠ›ã®90åº¦å³ï¼‰
                            let direction = Math.atan2(pressureGradientY, pressureGradientX) * 180 / Math.PI + 90;
                            if (direction < 0) direction += 360;
                            if (direction >= 360) direction -= 360;
                            
                            this.windField.push({
                                lat: lat,
                                lon: lon,
                                speed: wind.speed,
                                direction: direction,
                                u: wind.speed * Math.cos(direction * Math.PI / 180),
                                v: wind.speed * Math.sin(direction * Math.PI / 180)
                            });
                        }
                    }
                }
            }
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®æ™‚é–“ã‚¹ãƒ†ãƒƒãƒ—æ›´æ–°
            updateTimeStep() {
                this.timeStep++;
                
                // ä½æ°—åœ§ã®ç§»å‹•
                this.lowPressureCenters.forEach(low => {
                    low.lat += low.movement.dy * 0.1;
                    low.lon += low.movement.dx * 0.1;
                    
                    // å¢ƒç•Œå‡¦ç†
                    if (low.lat < 30) low.lat = 30;
                    if (low.lat > 45) low.lat = 45;
                    if (low.lon < 125) low.lon = 125;
                    if (low.lon > 145) low.lon = 145;
                });
                
                // é«˜æ°—åœ§ã®ç§»å‹•
                this.highPressureCenters.forEach(high => {
                    high.lat += high.movement.dy * 0.05;
                    high.lon += high.movement.dx * 0.05;
                    
                    // å¢ƒç•Œå‡¦ç†
                    if (high.lat < 30) high.lat = 30;
                    if (high.lat > 45) high.lat = 45;
                    if (high.lon < 125) high.lon = 125;
                    if (high.lon > 145) high.lon = 145;
                });
                
                // ç­‰åœ§ç·šã¨é¢¨å ´ã‚’å†è¨ˆç®—
                this.generateIsobars();
                this.calculateWindField();
            }
        }
        
        // ==================== 3. å¤©æ°—å›³æç”»ã‚¯ãƒ©ã‚¹ ====================
        class WeatherMapRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width = this.canvas.parentElement.clientWidth;
                this.height = this.canvas.height = 700;
                
                // åœ°å›³ç”»åƒï¼ˆã‚ãªãŸã®æä¾›ã•ã‚ŒãŸæ—¥æœ¬åœ°å›³ï¼‰
                this.mapImage = new Image();
                this.mapImage.src = 'japanmap.png'; // ã‚ãªãŸã®åœ°å›³ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«
                this.mapImage.onload = () => this.drawMap();
                
                // åº§æ¨™å¤‰æ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆæ—¥æœ¬å‘¨è¾ºï¼‰
                this.mapBounds = {
                    minLat: 30,
                    maxLat: 45,
                    minLon: 125,
                    maxLon: 145
                };
                
                this.animationId = null;
                this.isAnimating = false;
            }
            
            latLonToCanvas(lat, lon) {
                const x = ((lon - this.mapBounds.minLon) / (this.mapBounds.maxLon - this.mapBounds.minLon)) * this.width;
                const y = this.height - ((lat - this.mapBounds.minLat) / (this.mapBounds.maxLat - this.mapBounds.minLat)) * this.height;
                return { x, y };
            }
            
            drawMap() {
                // åœ°å›³ç”»åƒã‚’æç”»
                this.ctx.drawImage(this.mapImage, 0, 0, this.width, this.height);
                
                // ã‚°ãƒªãƒƒãƒ‰ç·šï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.lineWidth = 1;
                
                // çµŒåº¦ç·š
                for (let lon = 125; lon <= 145; lon += 5) {
                    const pos = this.latLonToCanvas(30, lon);
                    this.ctx.beginPath();
                    this.ctx.moveTo(pos.x, 0);
                    this.ctx.lineTo(pos.x, this.height);
                    this.ctx.stroke();
                    
                    // ãƒ©ãƒ™ãƒ«
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(`${lon}Â°E`, pos.x + 5, 20);
                }
                
                // ç·¯åº¦ç·š
                for (let lat = 30; lat <= 45; lat += 5) {
                    const pos = this.latLonToCanvas(lat, 125);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, pos.y);
                    this.ctx.lineTo(this.width, pos.y);
                    this.ctx.stroke();
                    
                    // ãƒ©ãƒ™ãƒ«
                    this.ctx.fillText(`${lat}Â°N`, 10, pos.y - 5);
                }
            }
            
            drawPressureCenters(lows, highs) {
                // ä½æ°—åœ§ä¸­å¿ƒï¼ˆèµ¤ï¼‰
                lows.forEach(low => {
                    const pos = this.latLonToCanvas(low.lat, low.lon);
                    
                    // ä¸­å¿ƒç‚¹
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#CC0000';
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#FFF';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // ã€Œä½ã€ãƒ©ãƒ™ãƒ«
                    this.ctx.fillStyle = '#FFF';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('ä½', pos.x, pos.y);
                    
                    // æ°—åœ§å€¤
                    this.ctx.fillStyle = '#CC0000';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.fillText(`${low.pressure.toFixed(1)}`, pos.x, pos.y - 20);
                    
                    // ç§»å‹•æ–¹å‘
                    this.drawMovementArrow(pos.x, pos.y, low.movement.direction, low.movement.speed);
                });
                
                // é«˜æ°—åœ§ä¸­å¿ƒï¼ˆé’ï¼‰
                highs.forEach(high => {
                    const pos = this.latLonToCanvas(high.lat, high.lon);
                    
                    // ä¸­å¿ƒç‚¹
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#0066CC';
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#FFF';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // ã€Œé«˜ã€ãƒ©ãƒ™ãƒ«
                    this.ctx.fillStyle = '#FFF';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('é«˜', pos.x, pos.y);
                    
                    // æ°—åœ§å€¤
                    this.ctx.fillStyle = '#0066CC';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.fillText(`${high.pressure.toFixed(1)}`, pos.x, pos.y - 20);
                    
                    // ç§»å‹•æ–¹å‘
                    this.drawMovementArrow(pos.x, pos.y, high.movement.direction, high.movement.speed);
                });
            }
            
            drawMovementArrow(x, y, direction, speed) {
                const length = Math.min(speed * 0.5, 30);
                const angle = (direction - 90) * Math.PI / 180; // åŒ—ã‚’0åº¦ã«èª¿æ•´
                
                const endX = x + length * Math.cos(angle);
                const endY = y + length * Math.sin(angle);
                
                // çŸ¢å°ã®ç·š
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(endX, endY);
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // çŸ¢å°ã®é ­
                this.ctx.beginPath();
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(
                    endX - 8 * Math.cos(angle - Math.PI/6),
                    endY - 8 * Math.sin(angle - Math.PI/6)
                );
                this.ctx.lineTo(
                    endX - 8 * Math.cos(angle + Math.PI/6),
                    endY - 8 * Math.sin(angle + Math.PI/6)
                );
                this.ctx.closePath();
                this.ctx.fillStyle = '#333';
                this.ctx.fill();
            }
            
            drawIsobars(isobars) {
                isobars.forEach(isobar => {
                    const pos = this.latLonToCanvas(isobar.center.lat, isobar.center.lon);
                    const radius = isobar.radius * (this.width / (this.mapBounds.maxLon - this.mapBounds.minLon)) / 111.32;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                    this.ctx.strokeStyle = isobar.type === 'high' ? '#0066CC' : '#CC0000';
                    this.ctx.lineWidth = 1.5;
                    this.ctx.setLineDash([5, 3]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    
                    // æ°—åœ§å€¤ãƒ©ãƒ™ãƒ«
                    const labelX = pos.x + radius * Math.cos(Math.PI/4);
                    const labelY = pos.y + radius * Math.sin(Math.PI/4);
                    
                    this.ctx.fillStyle = isobar.type === 'high' ? '#0066CC' : '#CC0000';
                    this.ctx.font = '10px Arial';
                    this.ctx.fillText(`${isobar.pressure} hPa`, labelX, labelY);
                });
            }
            
            drawWindField(winds) {
                winds.forEach(wind => {
                    const pos = this.latLonToCanvas(wind.lat, wind.lon);
                    
                    // é¢¨é€Ÿã«å¿œã˜ãŸçŸ¢å°ã®é•·ã•
                    const length = Math.min(wind.speed * 3, 40);
                    const angle = (wind.direction - 90) * Math.PI / 180;
                    
                    // é¢¨é€ŸãŒå°ã•ã„å ´åˆã¯æç”»ã—ãªã„
                    if (wind.speed < 1) return;
                    
                    // çŸ¢å°ã®ç·š
                    this.ctx.beginPath();
                    this.ctx.moveTo(pos.x, pos.y);
                    this.ctx.lineTo(
                        pos.x + length * Math.cos(angle),
                        pos.y + length * Math.sin(angle)
                    );
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = Math.min(wind.speed / 5, 3);
                    this.ctx.stroke();
                    
                    // ç¾½æ ¹ï¼ˆé¢¨é€Ÿã®è¡¨ç¾ï¼‰
                    const featherCount = Math.floor(wind.speed / 5);
                    for (let i = 1; i <= featherCount; i++) {
                        const featherPos = i / (featherCount + 1);
                        const featherX = pos.x + length * featherPos * Math.cos(angle);
                        const featherY = pos.y + length * featherPos * Math.sin(angle);
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(featherX, featherY);
                        this.ctx.lineTo(
                            featherX - 5 * Math.cos(angle + Math.PI/2),
                            featherY - 5 * Math.sin(angle + Math.PI/2)
                        );
                        this.ctx.strokeStyle = '#333';
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                    }
                });
            }
            
            drawWeatherConditions(location, weather, temperature, humidity) {
                const locations = {
                    kyoto: { name: "äº¬éƒ½", pos: this.latLonToCanvas(35.0116, 135.7681) },
                    nara: { name: "å¥ˆè‰¯", pos: this.latLonToCanvas(34.6851, 135.8048) },
                    kamakura: { name: "éŒå€‰", pos: this.latLonToCanvas(35.3192, 139.5500) },
                    hakata: { name: "åšå¤š", pos: this.latLonToCanvas(33.5902, 130.4017) },
                    osaka: { name: "å¤§å‚", pos: this.latLonToCanvas(34.6937, 135.5023) },
                    sendai: { name: "ä»™å°", pos: this.latLonToCanvas(38.2682, 140.8694) }
                };
                
                const loc = locations[location] || locations.kyoto;
                
                // å¤©æ°—è¨˜å·
                const weatherSymbols = {
                    sunny: 'â˜€ï¸',
                    cloudy: 'â˜ï¸',
                    rainy: 'ğŸŒ§ï¸',
                    snowy: 'â„ï¸',
                    stormy: 'â›ˆï¸',
                    foggy: 'ğŸŒ«ï¸'
                };
                
                // å ´æ‰€ãƒãƒ¼ã‚«ãƒ¼
                this.ctx.beginPath();
                this.ctx.arc(loc.pos.x, loc.pos.y, 15, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                this.ctx.fill();
                this.ctx.strokeStyle = '#4CAF50';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // å¤©æ°—æƒ…å ±
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(loc.name, loc.pos.x, loc.pos.y - 25);
                
                this.ctx.font = '20px Arial';
                this.ctx.fillText(weatherSymbols[weather] || 'â˜€ï¸', loc.pos.x, loc.pos.y + 5);
                
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`${temperature.toFixed(1)}Â°C`, loc.pos.x - 20, loc.pos.y + 25);
                this.ctx.fillText(`${humidity}%`, loc.pos.x + 20, loc.pos.y + 25);
                
                // é›¨ã®å ´åˆã¯é›¨åŸŸã‚’è¡¨ç¤º
                if (weather === 'rainy' || weather === 'stormy') {
                    this.drawRainArea(loc.pos.x, loc.pos.y);
                }
            }
            
            drawRainArea(centerX, centerY) {
                // é›¨åŸŸã®å††
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0, 102, 204, 0.1)';
                this.ctx.fill();
                this.ctx.strokeStyle = 'rgba(0, 102, 204, 0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // é›¨ç²’ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 80;
                    const dropX = centerX + distance * Math.cos(angle);
                    const dropY = centerY + distance * Math.sin(angle);
                    const length = 5 + Math.random() * 10;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(dropX, dropY);
                    this.ctx.lineTo(dropX, dropY + length);
                    this.ctx.strokeStyle = 'rgba(0, 102, 204, 0.5)';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
            }
            
            render(pressureField, location, weather, temperature, humidity) {
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // åœ°å›³ã‚’æç”»
                this.drawMap();
                
                // ç­‰åœ§ç·š
                this.drawIsobars(pressureField.isobars);
                
                // é¢¨å ´
                this.drawWindField(pressureField.winds);
                
                // æ°—åœ§ä¸­å¿ƒ
                this.drawPressureCenters(pressureField.lows, pressureField.highs);
                
                // å¤©æ°—æ¡ä»¶
                this.drawWeatherConditions(location, weather, temperature, humidity);
                
                // ã‚¿ã‚¤ãƒˆãƒ«
                this.ctx.fillStyle = '#1a237e';
                this.ctx.font = 'bold 24px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('å¹³å®‰æ™‚ä»£å¤©æ°—å›³', 20, 40);
                
                const year = document.getElementById('yearSelect').value;
                this.ctx.font = '16px Arial';
                this.ctx.fillText(`è¥¿æš¦ ${year}å¹´`, 20, 70);
            }
            
            startAnimation(pressureField, location, weather, temperature, humidity) {
                if (this.isAnimating) {
                    cancelAnimationFrame(this.animationId);
                }
                
                this.isAnimating = true;
                let frameCount = 0;
                
                const animate = () => {
                    frameCount++;
                    
                    // 10ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«æ°—åœ§å ´ã‚’æ›´æ–°
                    if (frameCount % 10 === 0) {
                        pressureField.updateTimeStep();
                    }
                    
                    this.render(pressureField, location, weather, temperature, humidity);
                    
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç¶™ç¶š
                    this.animationId = requestAnimationFrame(animate);
                };
                
                animate();
            }
            
            stopAnimation() {
                if (this.isAnimating) {
                    cancelAnimationFrame(this.animationId);
                    this.isAnimating = false;
                }
            }
        }
        
        // ==================== 4. å…¬å¼è¡¨ç¤ºã‚¯ãƒ©ã‚¹ ====================
        class FormulaDisplay {
            static showAllFormulas(engine, params) {
                const container = document.getElementById('formulasList');
                container.innerHTML = '';
                
                // å…¨ã¦ã®å…¬å¼ã‚’è¨ˆç®—ã—ã¦è¡¨ç¤º
                const formulas = [
                    // æ”¾å°„ãƒ»æ¸©åº¦ç³»
                    engine.radiativeEquilibrium(params.albedo),
                    engine.radiativeForcing(params.deltaF),
                    engine.lapseRateCorrection(params.temperature, params.elevation),
                    
                    // æ°—åœ§ãƒ»é«˜åº¦ç³»
                    engine.hydrostaticBalance(params.pressure, params.density),
                    engine.pressureAtHeight(params.pressure, params.elevation),
                    engine.idealGasLaw(params.pressure, params.temperature),
                    
                    // é¢¨ã®å…¬å¼
                    engine.coriolisParameter(params.latitude),
                    engine.geostrophicWind(params.pressureGradient, params.latitude),
                    engine.windSpeed(params.uWind, params.vWind),
                    
                    // æ¹¿åº¦ãƒ»æ°´è’¸æ°—
                    engine.saturationVaporPressure(params.temperature),
                    engine.relativeHumidity(params.vaporPressure, params.saturationPressure),
                    engine.specificHumidity(params.vaporPressure, params.pressure),
                    
                    // é™æ°´ãƒ»é›²
                    engine.upwardMotionCondition(params.divergence),
                    engine.rainfallEstimate(params.humidity, params.updraft),
                    engine.cloudCoverEstimate(params.humidity),
                    
                    // å‰ç·šãƒ»æ°—å›£
                    engine.frontIntensity(params.temperatureGradient),
                    engine.temperatureAdvection(params.vx, params.vy, params.dTdx, params.dTdy),
                    
                    // å¤§æ°—å®‰å®šåº¦
                    engine.dryAdiabaticLapseRate(),
                    engine.stabilityCondition(params.envLapse, params.dryLapse),
                    
                    // å¤§å¾ªç’°ãƒ»å­£ç¯€
                    engine.solarAltitudeAngle(params.latitude, params.declination, params.hourAngle),
                    engine.monsoonIndex(params.landTemp, params.seaTemp),
                    
                    // èª¤å·®ãƒ»è£œæ­£
                    engine.movingAverage(params.tempData, params.windowSize),
                    engine.biasCorrection(params.rawTemp, params.rawMean, params.obsMean),
                    engine.uncertaintyPropagation(params.sigma1, params.sigma2)
                ];
                
                formulas.forEach(formula => {
                    this.addFormulaCard(formula);
                });
            }
            
            static addFormulaCard(formula) {
                const container = document.getElementById('formulasList');
                
                const card = document.createElement('div');
                card.className = 'formula-card';
                
                let detailsHtml = '';
                if (formula.details) {
                    detailsHtml = '<div class="formula-details">';
                    for (const [key, value] of Object.entries(formula.details)) {
                        detailsHtml += `<strong>${key}:</strong> ${value}<br>`;
                    }
                    detailsHtml += '</div>';
                }
                
                card.innerHTML = `
                    <div class="formula-name">${formula.explanation}</div>
                    <div class="formula-equation">${formula.formula}</div>
                    <div>è¨ˆç®—çµæœ: <span class="formula-value">${typeof formula.value === 'number' ? formula.value.toFixed(3) : formula.value}</span></div>
                    ${detailsHtml}
                `;
                
                container.appendChild(card);
            }
        }
        
        // ==================== 5. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ– ====================
        document.addEventListener('DOMContentLoaded', function() {
            // ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
            const engine = new CompleteMeteorologicalEngine();
            const pressureField = new DynamicPressureField();
            const mapRenderer = new WeatherMapRenderer('weatherCanvas');
            
            // UIè¦ç´ ã®å–å¾—
            const yearSelect = document.getElementById('yearSelect');
            const yearValue = document.getElementById('yearValue');
            const tempSlider = document.getElementById('temperature');
            const tempValue = document.getElementById('tempValue');
            const humiditySlider = document.getElementById('humidity');
            const humidityValue = document.getElementById('humidityValue');
            const pressureSlider = document.getElementById('pressure');
            const pressureValue = document.getElementById('pressureValue');
            const ensoSlider = document.getElementById('enso');
            const ensoValue = document.getElementById('ensoValue');
            const eraDisplay = document.getElementById('eraDisplay');
            const weatherDisplay = document.getElementById('weatherDisplay');
            const locationDisplay = document.getElementById('locationDisplay');
            
            // ç¾åœ¨ã®é¸æŠçŠ¶æ…‹
            let currentLocation = 'kyoto';
            let currentWeather = 'sunny';
            let currentTemperature = 24.5;
            let currentHumidity = 60;
            let currentPressure = 1013;
            let currentENSO = 0;
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
            yearSelect.addEventListener('input', function() {
                const year = parseInt(this.value);
                let era = "å¹³å®‰æ™‚ä»£";
                if (year < 794) era = "å¥ˆè‰¯æ™‚ä»£";
                else if (year < 1185) era = "å¹³å®‰æ™‚ä»£";
                else era = "éŒå€‰æ™‚ä»£";
                
                yearValue.textContent = `${era} (${year}å¹´)`;
                eraDisplay.textContent = `${era} (è¥¿æš¦${year}å¹´)`;
            });
            
            tempSlider.addEventListener('input', function() {
                currentTemperature = parseFloat(this.value);
                tempValue.textContent = this.value;
            });
            
            humiditySlider.addEventListener('input', function() {
                currentHumidity = parseInt(this.value);
                humidityValue.textContent = this.value;
            });
            
            pressureSlider.addEventListener('input', function() {
                currentPressure = parseInt(this.value);
                pressureValue.textContent = this.value;
            });
            
            ensoSlider.addEventListener('input', function() {
                currentENSO = parseFloat(this.value);
                ensoValue.textContent = this.value;
            });
            
            // å ´æ‰€é¸æŠãƒœã‚¿ãƒ³
            document.querySelectorAll('.location-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.location-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentLocation = this.dataset.location;
                    locationDisplay.textContent = `å ´æ‰€: ${this.textContent}`;
                    updateWeather();
                });
            });
            
            // å¤©æ°—æ¡ä»¶ãƒœã‚¿ãƒ³
            document.querySelectorAll('.condition-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.condition-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentWeather = this.dataset.weather;
                    
                    const weatherNames = {
                        sunny: 'æ™´ã‚Œ',
                        cloudy: 'æ›‡ã‚Š',
                        rainy: 'é›¨',
                        snowy: 'é›ª',
                        stormy: 'åµ',
                        foggy: 'éœ§'
                    };
                    
                    weatherDisplay.textContent = `å¤©æ°—: ${weatherNames[currentWeather]}`;
                    updateWeather();
                });
            });
            
            // æ°—è±¡ç”Ÿæˆãƒœã‚¿ãƒ³
            document.getElementById('generateBtn').addEventListener('click', function() {
                updateWeather();
            });
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³
            document.getElementById('animateBtn').addEventListener('click', function() {
                mapRenderer.startAnimation(
                    pressureField,
                    currentLocation,
                    currentWeather,
                    currentTemperature,
                    currentHumidity
                );
                this.innerHTML = '<i class="fas fa-pause"></i> ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢';
                this.onclick = function() {
                    mapRenderer.stopAnimation();
                    this.innerHTML = '<i class="fas fa-play"></i> ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹';
                    this.onclick = arguments.callee;
                };
            });
            
            // å…¬å¼è¡¨ç¤ºãƒœã‚¿ãƒ³
            document.getElementById('formulaBtn').addEventListener('click', function() {
                const params = {
                    albedo: 0.3,
                    deltaF: 1.5,
                    temperature: currentTemperature,
                    elevation: 50,
                    pressure: currentPressure,
                    density: 1.225,
                    latitude: 35.0,
                    pressureGradient: 2.0,
                    uWind: 5.0,
                    vWind: 2.0,
                    vaporPressure: 10.0,
                    saturationPressure: 20.0,
                    humidity: currentHumidity,
                    divergence: -0.5,
                    updraft: 0.2,
                    temperatureGradient: 5.0,
                    vx: 3.0,
                    vy: 1.0,
                    dTdx: 0.1,
                    dTdy: 0.05,
                    envLapse: 5.0,
                    dryLapse: 9.8,
                    declination: 20.0,
                    hourAngle: 12.0,
                    landTemp: currentTemperature,
                    seaTemp: currentTemperature - 2.0,
                    tempData: [24.0, 24.5, 25.0, 24.8, 24.3],
                    windowSize: 3,
                    rawTemp: 24.5,
                    rawMean: 24.0,
                    obsMean: 24.2,
                    sigma1: 0.5,
                    sigma2: 0.3
                };
                
                FormulaDisplay.showAllFormulas(engine, params);
                
                // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦å…¬å¼ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º
                document.getElementById('formulaPanel').scrollIntoView({ behavior: 'smooth' });
            });
            
            // å¤©æ°—å›³æ›´æ–°é–¢æ•°
            function updateWeather() {
                const pressureData = pressureField.generatePressureField(
                    currentLocation,
                    currentWeather,
                    currentTemperature,
                    currentHumidity,
                    currentPressure,
                    currentENSO
                );
                
                mapRenderer.render(
                    pressureData,
                    currentLocation,
                    currentWeather,
                    currentTemperature,
                    currentHumidity
                );
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Ÿè¡Œä¸­ã§ã‚ã‚Œã°æ›´æ–°
                if (mapRenderer.isAnimating) {
                    mapRenderer.stopAnimation();
                    document.getElementById('animateBtn').innerHTML = '<i class="fas fa-play"></i> ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹';
                    document.getElementById('animateBtn').onclick = function() {
                        mapRenderer.startAnimation(
                            pressureField,
                            currentLocation,
                            currentWeather,
                            currentTemperature,
                            currentHumidity
                        );
                        this.innerHTML = '<i class="fas fa-pause"></i> ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢';
                        this.onclick = arguments.callee;
                    };
                }
            }
            
            // åˆæœŸè¡¨ç¤º
            updateWeather();
            
            console.log('å¹³å®‰æ™‚ä»£æ°—è±¡å†ç¾ã‚·ã‚¹ãƒ†ãƒ ãŒèµ·å‹•ã—ã¾ã—ãŸ');
            console.log('ä½¿ç”¨ã—ã¦ã„ã‚‹ç‰©ç†å…¬å¼: æ”¾å°„å¹³è¡¡ã€åœ°è¡¡é¢¨ã€é™æ°´åœ§å¹³è¡¡ã€ãƒã‚°ãƒŒã‚¹å¼ãªã©å…¨27å…¬å¼');
        });
    </script>
</body>
</html>